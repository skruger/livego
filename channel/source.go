package channel

import (
	"github.com/gwuhaolin/livego/av"
	log "github.com/sirupsen/logrus"
)

// Channel sources get added to RTMP streams as an av.WriteCloser
// These sources receive the data that the channel output will use
// a channel output implements the av.ReadCloser interface
// The channel instance is always outputting something through the av.ReadCloser
// interface and can get content from one of these sources:
// 1. Pre-content slate asset
// 2. Connected RTMP stream (multiple can be ready and a failover order defined)
// 3. Missing content slate asset
// 4. Static played asset (similar to slate assets, but longer and filling a schedule)
// 5. Post-content slate asset (static played asset on repeat)

// Sources are developed first to gain insight into what the raw av.Packet
// type looks like, how it can be buffered, and how it can be generated by
// reading a raw asset file from the disk or through ffmpeg transformations.

type channelSource struct {
}

func NewStreamSource() av.WriteCloser {
	return &channelSource{}
}

func (s channelSource) Write(packet *av.Packet) error {
	if packet.IsAudio {
		log.Debug("Got audio packet")
	}
	return nil
}

func (s channelSource) Close(err error) {

}

func (s channelSource) Info() av.Info {
	return av.Info{}
}

func (s channelSource) Alive() bool {
	return true
}

func (s channelSource) CalcBaseTimestamp() {

}
